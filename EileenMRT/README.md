# LAB 3: Mini Reliable Transport
## Eileen Xia

`updsender.py` UdpSender class\
`udpreceiver.py` UdpReceiver class \
`packet.py` Packet class\
`clientmsg.py` ClientMessage class to keeps track of all packets that a client has sent\
`consts.py` Constants/variables used in the other programs\
\
`generate.py` generates 10 lines of data (number of lines can be changed)\
`test_receiver.py` tests UdpReceiver. Usage: test_receiver.py datacorrupt packetloss delay (last three args are Booleans for testing)\
`test_sender.py` tests UdpSender with data from stdin. Usage: test_sender.py delay (last arg is Boolean for testing)\
`test_sendfile.py` tests UdpSender sending a large file; if the file’s too large, it will be split into chunks\
`test_outoforder.py` test UdpSender sending packets out of order

__1)__ My program handles packet loss by creating an object ClientMessage for each client which holds a dictionary of each fragment number and packet pair. The first fragment number is 0 and the last fragment number is the fragNum of the RCLS packet sent. Once the last fragment is sent, the receiver checks for any missing fragment numbers in the range 0 to last fragment number and requests a resend of those packets with packet type RSND. 
To test for this, I added a flag packetloss in my UdpReceiver class that, when set to True, will randomly drop around 10% of incoming packets. So, I start my receiver with `python test_receiver.py False True False` to turn on the packetloss functionality. Then, in a separate window, I start my sender with `python test_sender.py False` (to feed messages through stdin) or `python generate.py | python test_sender.py False` to use the data from generate. You should see in the receiver window any messages about “Missing packets [number] from [sender addr]”, and in the sender side a request to resend the missing packet with the printed message “Asked to resend [number]…”.

__2)__ My program handles data corruption by using a checksum. In my Packet class, I have functions to pack and unpack a given packet object. The pack is used before sending out a packet and unpack and used upon receiving. If there is no data corruption, then the checksum of the payload before packing is the same as the checksum after unpacking. If there is data corruption, then the packet is dropped and the sender will not receive an acknowledgment for that packet, in which case the sender will try to send again.
To test for this, I add a flag datacorrupt in my UdpReceiver class that, when set to True, will randomly read around 10% of incoming packets as invalid/corrupt. So, I start my receiver with `python test_receiver.py True False False` to turn on the datacorrupt functionality. Then, in a separate window, I start my sender with `python test_sender.py False` (to feed messages through stdin) or `python generate.py | python test_sender.py False` to use the data from generate. You should see in the receiver window any messages about “Corrupt data on fragnum [num]”, in which the corrupt packet will be dropped and the sender will resend.

__3)__ My program handles out-of-order delivery by keeping received data in a dictionary and assembling the completed message in order after the last packet has been sent. In my UdpReceiver class, I have an attribute clientmsgs that maps each client to their ClientMessage. The ClientMessage is my class that maps fragment number to packet. Each incoming packet is added to clientmsgs, and after the last message has been sent and missing packets are accounted for, the ClientMessage class will construct the complete message by concatenating each fragment message in order.
To test for this, I start my receiver with `python test_receiver.py False False False` in one window and start my `python test_outoforder.py` in another window. This program sends messages 25 messages in a scrambled order. After it is done sending, you will see in the receiver window that the complete fragments are reassembled in the correct order. (Any flags in the receiver can be set to True to test with packetloss or datacorrupt).

__4)__ My program handles high latency in a couple of ways. First, I use a separate thread for handling acknowledgements on the receiver end in order to avoid blocking the application. The sender has a parallel thread that sends data. Also, the sender employs an output window. When the window is full, no additional packets are sent until one of the packets in the window receives an acknowledgement. If a packet has been in the window more than 10 seconds, the packet is resent. This handles traffic by assuring data too much data isn’t being sent at once. 
To test this, I have a input argument for test_receiver and test_sender for creating random delays up to 5 seconds. To test this, I start the receiver with `python test_receiver False False True`. In another window, I start the sender with `python generate.py | python test_sender.py True`. Although it will be very slow in sending data, this does not raise any exceptions and the complete message will be received eventually. 

__5)__ My program is able to handle small amounts of data because each fragment payload has no minimum size. I test this by starting my receiver with `python test_receiver.py False False False` and starting my sender in another window with `python test_sender.py False`. Then, in the window for test_sender, I input a single character, press enter, then request disconnect with CTRL+D and enter. You will see the receiver has the complete message after it the sender leaves. Another test is to connect, send no messages, and immediately disconnect with CTRL+D and enter. This raises no exceptions.

__6)__ My program is able to handle large data by splitting messages into chunks if they are too large. The `SendFile` function in udpsender takes an input file and splits it into chunks, sending each chunk as a fragment. To test sending a large file, I run `python test_receiver.py False False False` in one window. In another window, run `python test_sendfile.py [filepath]`. For large files, you will see the message split into chunk fragments; once the last fragment is received, the full message is formed at the receiver end. 

__7)__ My program handles flow control by separating each client and their messages. In my UdpReceiver class, I have the clientmsgs attribute that maps client to their messages. So, if multiple senders connect, they can all send messages because the receiver can keep track of which message comes from who. You can see this when you test multiple senders. In one window, run the receiver with `python test_receiver.py False False False`. In two other windows (or as many as N, which is currently set to 10 in test_receiver), start the senders. The input piped to the sender can vary, but I use `python generate.py | python test_sender.py False` and run this command in two separate windows very close to each other so they will be connected at the same time. You will see that although both are running at the same time, no packets are being resent, indicating that no sender is stuck in its send command waiting for the receiver. The results can be seen even better by turning on the flags for packetloss, datacorrupt, and/or delay (running test_receiver with True statements rather than False), and also generating 100 lines of data in generate.py rather than 10.

__8)__ My test_sender uses connect, send, and disconnect. It first calls connect to create a connection, then it sends data with send, until finally it requests disconnect. My test_receiver used open to start the server, accept1 to accept a connection, and receive1 to receive data. To close the connection, my receiver calls close. Acceptall and probe were not used, because accept1 and receive1 are used instead. However, these can easily be used by replacing accept1 with acceptall and receive1 with probe.

__9)__ The functions that were not used were acceptall and probe. To test, I replace `udp.mrt_accept1()` with `udp.mrt_accept_all()`. Similarly, I replace `udp.mrt_receive1()` with `udp.mrt_probe()`. These texts are commented out and can be seen in `test_receiver.py`. I tested these functions by starting my test_receiver and test_sender in the same way as above, but making sure my test_receiver code is using acceptall and probe in place of accept1 and receive1.

__10)__ In `udpsender.py` : `mrt_connect()`, `mrt_send()`, `mrt_disconnect()`\
In `udpreceiver.py` : `mrt_open()`, `mrt_accept1()`, `mrt_accept_all()`, `mrt_receive()`, `mrt_probe()`, `mrt_close()`

__11)__ To test my program with a large amount of data, run `python test_receiver.py False False False` in one window to start the receiver. The last two arguments in starting receiver are flags indicating whether you want to test for data corruption or packet loss. If you set the first argument to True, random packets will be corrupted. If you set the second argument to True, random packets will be lost. If you set the third argument to True, random delay will be generated. In another window, run `python test_sendfile.py [filepath]` with an input file of your choice. (Or, you can run `cat [file] | python test_sender.py False` to pipe the file, but this is different because I read line by line from stdin rather than splitting the whole file into chunks like the first test.)

__12)__ To test my program with a small amount of data, run `python test_receiver.py False False False` in one window. (Again, these can be set to True if you want to test data corruption or packet loss). In another window, run `python test_sender.py False` and write a small message as input. For example, I tested this with a single character. This also works if you don’t send any messages, and just connect and disconnect. The CTRL+D command indicates a disconnect request. Or, instead of manually writing a message, you can run `python generate.py | python test_sender.py False`. The generate program creates 10 short lines of data. 

__13)__ To test my program for flow-control, run `python test_receiver.py False False False` in one window. (Again, these can be set to True if you want to test data corruption or packet loss or delay). In two other windows, run `python generate.py | python test_sender.py False` at the same time to see how the receiver acts with multiple clients. It is more interesting to turn the first two receiver flags to True and change the number of lines generated in generate.py to 100. 

__14)__ Functions not used were accept_all and probe. To use them, in test_receiver, comment out accept1 and receive1 and uncomment the code using accept_all and probe.

__15)__ First, I create a Packet class, defined in `packet.py`. Each packet has a field for the connection ID, its checksum, the message type, fragment number, message payload, an indicator if it is the last packet, and a check to see that the checksum is valid. The connection ID, connId is assigned by the receiver and is a unique identifier. The fragment number starts from 0 and increments for each new packet. There are 7 message types: RCON (1, request a connection), ACON (2, accept connection), DATA (3, send data), ADAT (4, accept data), RCLS (5, request to close connection), ACLS (6, accept close), and RSND (7, request to resend data). These constants are defined in `consts.py`. The functions `pack()` and `unpack()` pack up this information into a packet when sending, and unpack when receiving, so that the attributes can be easily identifiable. In unpacking a packet, it checks for data corruption by comparing the calculated checksum with the original checksum.

Next, I have a ClientMessage class to keep track of all packets that a client has sent, defined in `clientmsg.py`. Each client message consists of Packet objects. A dictionary is used to keep track of all packets received so far; the key is the fragNum (fragment number of packet) and the value is the Packet. To add packets as they come in, I check to make sure the fragNum is not in the dictionary before adding. This dictionary thus handles duplicate packets (duplicates are dropped if the fragNum has already been seen). Because the packet type RCLS indicates that it is the final message, I know the fragNum of this last packet. Using this number as input for  `checkMissingPackets()`, I can then check for missing packets by checking missing fragment numbers between the initial fragment number 0 and the last. This function then returns all detected missing packets (None if none are missing). The function `construcMessage()` constructs the complete message by combining each packet’s message in order. The ClientMessage also has functionality dumpToFile which will dump payload into a temporary file if the size exceed DUMP_SIZE_THRESHOLD (it’s set to 10kb now in consts.py) to deal with if the data is getting way too big. 

The two main classes I create are UdpSender and UdpReceiver, defined in `udpsender.py` and `udpreceiver.py` respectively. First, UdpSender has the following attributes: sock (socket connection), connId (unique connection identifier), addr (the server address), close (indicates if its in a closed state/not connected), window (a dictionary keeping track of which packets arein the window), and winSize (a constant for the window size). UdpSender also implements the functions `mrt_connect()`, `mrt_send()`, and `mrt_disconnect()`. To connect, the sender sends a packet of type RCON (requesting connection) and knows it has successfully connected if it receives back a packet of type ACON. The receiver assigns a connection ID to the sender and places this information in the connId attribute of the ACON packet; the sender can then assign this ID to its connId attribute.  If the ACON is not received, the sender tries again until the return packet type is ACON. To send data, the sender sends a packet with type DATA or RCLS (default is DATA). If the sender sends type DATA and receives packet type ADAT, acknowledging this data, then it knows it is ready for sending the next packet. Otherwise, if no ADAT is received or if RSND (request resend) is sent instead, the sender sleeps for 100ms before resending the data. If the sender sends type RCLS and receives packet type ACLS, `mrt_disconnect()` is called to close the connections. If ACLS is not received or if RSND is sent instead, the sender sleeps before resending. 

For handling large files, the function `SendFile()` in `udpsender.py` sends an input file in chunks. Each chunk is sent as a packet; the chunk size is 3072 (3kb), as set in `consts.py`. The window works by holding a maximum number of fragments in a buffer until they receive acknowledgement. If the window is full, the sender waits until a packet is acknowledged and can be removed from the window. Packets that have been in the window greater than 10 seconds will be resent. The window is helpful in avoiding generating too much traffic when the receiver is busy.

The UdpReceiver class has the following attributes: sock, N (how many senders allowed to connect), addr, connSeqNo (used for connection IDs that are sent back to clients, increments from 0), client_map (dictionary with key tuple ('machine_addr', portno) and value is connection id), connid_client_map (map connId to client addr), clientmsgs (the key is tuple ('machine_addr', portno), the value is ClientMessage), packetloss (used for testing packet loss), and datacorrupt (used for testing data corruption). A socket server is created in `mrt_open()`. To assign a connection ID to each client, `mrt_register()` first checks if the client exists in the client map, and adds it if not, if the number of clients doesn’t exceed N. 

The `processData()` function processes the received data and determines how to acknowledge it. First, because the Packet object checks if a packet isValid (checksum is correct), the receiver first makes sure the data is not corrupted. (If the packetloss or datacorrupt flags are set to true, random packets will be "lost" or “corrupted” respectively, for the purpose of testing). If the data is corrupted, the receiver sends a RSND packet (request resend). If the packet type received is RCON (requesting connection), the receiver registers the client with a connection ID (using the connSeqNo) and send back a ACON. RSND is sent in the case that mrt_register failed, ie if the number of clients exceeds N. Next, if the packet type received is DATA, the message is added to the dictionary clientmsgs for the corresponding client as a ClientMessage object and a ADAT is sent. This will handle missing and duplicate data, as described above. Last, if the packet type received is RCLS, the receiver first checks if that client has missing packets and sends RSND for each of the missing packets. Otherwise, a complete message is received and the close can be acknowledged with ACLS. The ClientMessage object’s `constructMessage()` function constructs the message from all packets in order and the client’s client_map and clientmsgs are deleted upon close. `mrt_accept1()` uses the `processData()` to accept one connection from a RCON packet, and `mrt_accept_all()` uses this to accept all incoming connections. `mrt_receive1()` works like accept1, for all message types other than RCON. 

A separate thread on the receiver side is created for handling acknowledgments. The thread uses a FIFO queue to read data and send acknowledgements back to the corresponding client. A separate parallel thread is used on the sender side to send messages in order to avoid blocking the application.





